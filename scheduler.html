<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0f0c29">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AION Retail EU - Schedule</title>
    <link rel="shortcut icon" href="https://assets.playnccdn.com/common/aion.ico" type="image/x-icon">
    <link rel="icon" href="https://assets.playnccdn.com/common/aion.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="https://assets.playnccdn.com/common/aion.ico">
    <link rel="stylesheet" href="assets/css/aion-tools.css?v=3.1">
</head>
<body class="page-scheduler">
    <a href="aion.html" class="home-button">üè† Tools Hub</a>
    <div class="container">
        <h1>AION Retail EU - Schedule</h1>
        
        <div class="time-display-section">
            <div class="time-box game-time">
                <div class="time-label">Game Time (Atreia)</div>
                <div class="time-value" id="gameTime">--:--:--</div>
                <div class="time-date" id="gameDate">--</div>
            </div>
            <div class="time-box server-time">
                <div class="time-label">Server Time (UTC+1)</div>
                <div class="time-value" id="serverTime">--:--:--</div>
                <div class="time-date" id="serverDate">--</div>
            </div>
            <div class="time-box local-time">
                <div class="time-label">Your Local Time</div>
                <div class="time-value" id="localTime">--:--:--</div>
                <div class="time-date" id="localDate">--</div>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item active" data-event-type="dumaha">
                <div class="legend-color dumaha-altar"></div>
                <span>Dumaha Altar</span>
            </div>
            <div class="legend-item active" data-event-type="mastarius">
                <div class="legend-color mastarius-veille"></div>
                <span>Mastarius/Veille</span>
            </div>
            <div class="legend-item active" data-event-type="sarna">
                <div class="legend-color sarna"></div>
                <span>Sarna</span>
            </div>
            <div class="legend-item active" data-event-type="fortress">
                <div class="legend-color fortress"></div>
                <span>Fortress Siege</span>
            </div>
            <div class="legend-item active" data-event-type="arena">
                <div class="legend-color arena-chaos"></div>
                <span>Arena of Chaos</span>
            </div>
        </div>

        <div class="next-event-section">
            <div class="next-event-title">‚è≥ Time until next event:</div>
            <div class="next-event-info" id="nextEventInfo">Calculating...</div>
        </div>

        <div class="scheduler-controls">
            <button id="toggleEmptyHoursBtn" class="plain-button">Hide empty hours</button>
        </div>

        <div class="scheduler-grid-wrapper">
            <div class="scheduler-header">
                <div class="day-header">Local Time</div>
                <div class="day-header" data-day="0">Monday</div>
                <div class="day-header" data-day="1">Tuesday</div>
                <div class="day-header" data-day="2">Wednesday</div>
                <div class="day-header" data-day="3">Thursday</div>
                <div class="day-header" data-day="4">Friday</div>
                <div class="day-header" data-day="5">Saturday</div>
                <div class="day-header" data-day="6">Sunday</div>
            </div>

            <div class="scheduler-grid" id="schedulerGrid">
                <!-- Populated by JS -->
            </div>
            <div class="schedule-notes" id="scheduleNotes">Schedule shows server (UTC+1) events converted to your local time. If this area is empty there are no scheduled events for your timezone.</div>
        </div>

        <div class="schedule-notes"><br>Notes:
            <br><br>Event times are based on server time (UTC+1) and may be subject to change. Always double-check in-game for the most accurate schedule.
            <br><br>Core and Prades rifts appear at :05 after the hour, while Bassen rift appear at :00.
            <br><br>Use the legend to filter events by type.
        </div>
    </div>

    <div class="footer">
        <div class="footer-actions">
            <a href="https://discordapp.com/users/158658357606088704" target="_blank" class="discord-button">
                <svg class="discord-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.216-1.975a.076.076 0 0 0-.042-.106a13.107 13.107 0 0 1-1.873-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.294a.074.074 0 0 1 .076-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.294a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.963 19.963 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-4.467.072-8.339-2.115-11.769a.06.06 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-.965-2.157-2.156c0-1.193.964-2.157 2.157-2.157c1.193 0 2.156.964 2.157 2.157c0 1.19-.964 2.156-2.157 2.156zm7.975 0c-1.183 0-2.157-.965-2.157-2.156c0-1.193.965-2.157 2.157-2.157c1.192 0 2.156.964 2.157 2.157c0 1.19-.965 2.156-2.157 2.156z"/>
                </svg>
                Support & Feedback
            </a>
        </div>

        <div class="copyright">
            ¬© <span id="copyright-year"></span> <a href="myAionProfiles.html"><strong>15TAN</strong></a> - AION Retail EU Schedule
        </div>

        <div class="disclaimer">
            This website is a non-commercial fan project. AION and all related images/assets are trademarks or registered trademarks of NCSoft Corporation and Gameforge. All rights reserved.
        </div>
    </div>

    <script>
        // Events schedule (server time in 24-hour format)
        const events = [
            // Dumaha Altar
            { name: 'Dumaha Altar', type: 'dumaha', days: [0, 2, 4, 6], times: ['14:00', '20:00'] },
            // Mastarius/Veille
            { name: 'Mastarius/Veille', type: 'mastarius', days: [1, 4, 5], times: ['13:00', '22:00'] },
            // Sarna
            { name: 'Sarna', type: 'sarna', days: [1, 4, 5], times: ['13:30', '22:30'] },
            // Fortress Sieges
            { name: 'Inggison + Gelkmaros + Core', type: 'fortress', days: [3, 6], times: ['21:00'] },
            { name: 'Bassen', type: 'fortress', days: [3], times: ['22:00'] },
            { name: 'Prades', type: 'fortress', days: [6], times: ['22:00'] },
            // Arena of Chaos
            { name: 'Arena of Chaos', type: 'arena', days: [0, 2, 4, 6], times: ['12:00', '19:00', '00:00'] }
        ];

        // Tracks last hour we auto-scrolled to, so we only scroll on hour change
        let lastAutoScrollHour = null;

        // Get current server time (UTC+1)
        function getServerTime() {
            const now = new Date();
            // getTimezoneOffset() returns minutes BEHIND UTC (negative for ahead)
            // For UTC+2: returns -120 (120 minutes ahead)
            // Server is UTC+1, so we need to adjust by the difference
            const localOffsetMs = now.getTimezoneOffset() * 60 * 1000;
            const serverOffsetMs = -60 * 60 * 1000; // UTC+1
            const adjustmentMs = localOffsetMs - serverOffsetMs;
            const serverTime = new Date(now.getTime() + adjustmentMs);
            return serverTime;
        }

        function formatTime(hours, minutes, seconds = 0, includeSeconds = true) {
            if (includeSeconds) {
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function formatDate(year, month, day) {
            return `${String(day).padStart(2, '0')}.${String(month).padStart(2, '0')}.${year}`;
        }

        function updateTimeDisplays() {
            const now = new Date();
            const serverTime = getServerTime();
            const gameTime = getAionGameTime(serverTime);
            
            const serverHours = String(serverTime.getHours()).padStart(2, '0');
            const serverMinutes = String(serverTime.getMinutes()).padStart(2, '0');
            const serverSeconds = String(serverTime.getSeconds()).padStart(2, '0');
            const serverDay = String(serverTime.getDate()).padStart(2, '0');
            const serverMonth = String(serverTime.getMonth() + 1).padStart(2, '0');
            const serverYear = serverTime.getFullYear();

            document.getElementById('serverTime').textContent = `${serverHours}:${serverMinutes}:${serverSeconds}`;
            document.getElementById('serverDate').textContent = `${serverDay}.${serverMonth}.${serverYear}`;
            
            document.getElementById('gameTime').textContent = gameTime.time;
            document.getElementById('gameDate').textContent = gameTime.date;

            // Local time
            const localHours = String(now.getHours()).padStart(2, '0');
            const localMinutes = String(now.getMinutes()).padStart(2, '0');
            const localSeconds = String(now.getSeconds()).padStart(2, '0');
            const localDay = String(now.getDate()).padStart(2, '0');
            const localMonth = String(now.getMonth() + 1).padStart(2, '0');
            const localYear = now.getFullYear();

            document.getElementById('localTime').textContent = `${localHours}:${localMinutes}:${localSeconds}`;
            document.getElementById('localDate').textContent = `${localDay}.${localMonth}.${localYear}`;

            // Update local time label to include UTC offset (e.g. UTC+2 or UTC-5:30)
            const offsetMinutes = -now.getTimezoneOffset(); // minutes offset from UTC
            const sign = offsetMinutes >= 0 ? '+' : '-';
            const absMinutes = Math.abs(offsetMinutes);
            const offsetH = Math.floor(absMinutes / 60);
            const offsetM = absMinutes % 60;
            const offsetStr = offsetM === 0 ? `UTC${sign}${offsetH}` : `UTC${sign}${offsetH}:${String(offsetM).padStart(2,'0')}`;
            const localLabel = document.querySelector('.local-time .time-label');
            if (localLabel) {
                localLabel.textContent = `Your Local Time (${offsetStr})`;
            }

            updateNextEvent();
        }

        function getNextEvent() {
            const now = new Date();
            const currentHours = now.getHours();
            const currentMinutes = now.getMinutes();
            const currentDayOfWeek = now.getDay() === 0 ? 6 : now.getDay() - 1; // Sunday = 6, Monday = 0
            const currentTimeInMinutes = currentHours * 60 + currentMinutes;

            let nextEvent = null;
            let minWait = Infinity;

            for (let event of events) {
                for (let day of event.days) {
                    for (let timeStr of event.times) {
                        // Convert server time event to local time
                        const [serverHour, serverMinute] = timeStr.split(':').map(Number);
                        const { hour: localHour, dayOffset } = convertServerTimeToLocal(serverHour, serverMinute);
                        const eventMinutes = Math.floor(localHour) * 60 + serverMinute;
                        
                        // Adjust day if timezone conversion caused day shift
                        let eventDay = day + dayOffset;
                        if (eventDay < 0) eventDay += 7;
                        if (eventDay >= 7) eventDay -= 7;
                        
                        let waitMinutes = 0;

                        if (eventDay === currentDayOfWeek && eventMinutes > currentTimeInMinutes) {
                            waitMinutes = eventMinutes - currentTimeInMinutes;
                        } else if (eventDay > currentDayOfWeek) {
                            const daysToAdd = eventDay - currentDayOfWeek;
                            waitMinutes = (daysToAdd * 24 * 60) + (eventMinutes - currentTimeInMinutes);
                        } else {
                            const daysToAdd = 7 - currentDayOfWeek + eventDay;
                            waitMinutes = (daysToAdd * 24 * 60) + (eventMinutes - currentTimeInMinutes);
                        }

                        if (waitMinutes >= 0 && waitMinutes < minWait) {
                            minWait = waitMinutes;
                            nextEvent = { ...event, waitMinutes };
                        }
                    }
                }
            }

            return nextEvent;
        }

        function updateNextEvent() {
            const nextEvent = getNextEvent();
            const infoDiv = document.getElementById('nextEventInfo');

            if (nextEvent) {
                const hours = Math.floor(nextEvent.waitMinutes / 60);
                const minutes = Math.floor(nextEvent.waitMinutes % 60);
                const seconds = 60 - new Date().getSeconds();

                let timeStr = '';
                if (hours > 0) {
                    timeStr = `${hours}h ${minutes}m ${seconds}s`;
                } else {
                    timeStr = `${minutes}m ${seconds}s`;
                }

                infoDiv.textContent = `${nextEvent.name} - ${timeStr}`;
                infoDiv.style.color = getEventColor(nextEvent.type);
            }
        }

        function getEventColor(type) {
            const colors = {
                'dumaha': '#c49c3a',
                'mastarius': '#42a5f5',
                'sarna': '#5442f5',
                'fortress': '#ef5350',
                'arena': '#ab47bc'
            };
            return colors[type] || '#fff';
        }

        function convertServerTimeToLocal(serverHour, serverMinute) {
            // Get local timezone offset
            const now = new Date();
            const localOffsetHours = -now.getTimezoneOffset() / 60;
            const timezoneDiffHours = localOffsetHours - 1; // Server is UTC+1
            
            let localHour = serverHour + timezoneDiffHours;
            let dayOffset = 0;
            
            if (localHour >= 24) {
                localHour -= 24;
                dayOffset = 1;
            } else if (localHour < 0) {
                localHour += 24;
                dayOffset = -1;
            }
            
            return { hour: localHour, dayOffset: dayOffset };
        }

        function shortenEventName(eventName) {
            const shortNames = {
                'Dumaha Altar': 'D. Altar',
                'Mastarius/Veille': 'Mast. Veille',
                'Sarna': 'Sarna',
                'Inggison + Gelkmaros + Core': 'Siege',
                'Bassen': 'Siege',
                'Prades': 'Siege',
                'Arena of Chaos': 'Chaos'
            };
            return shortNames[eventName] || eventName;
        }

        function createSchedulerGrid() {
            const grid = document.getElementById('schedulerGrid');
            grid.innerHTML = '';
            
            const now = new Date();
            const currentHour = now.getHours();

            // Get all unique local hours that have events
            const hoursWithEvents = new Set();
            events.forEach(event => {
                event.times.forEach(timeStr => {
                    const [serverHour, serverMinute] = timeStr.split(':').map(Number);
                    const { hour: localHour } = convertServerTimeToLocal(serverHour, serverMinute);
                    hoursWithEvents.add(localHour);
                });
            });

            // Create rows for all 24 hours
            for (let localHour = 0; localHour < 24; localHour++) {
                const hasEvents = hoursWithEvents.has(localHour);
                const isCurrentHour = localHour === currentHour;
                
                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.dataset.hour = localHour;
                if (!hasEvents) {
                    hourLabel.classList.add('hour-label-empty');
                }
                if (isCurrentHour) {
                    hourLabel.classList.add('current-hour-label');
                }
                hourLabel.textContent = String(localHour).padStart(2, '0') + ':00';
                grid.appendChild(hourLabel);

                // Create 7 columns for days of week
                for (let day = 0; day < 7; day++) {
                    const cell = document.createElement('div');
                    cell.className = 'scheduler-cell';
                    cell.dataset.day = day;
                    cell.dataset.hour = localHour;
                    if (!hasEvents) {
                        cell.classList.add('scheduler-cell-empty');
                    }
                    // Add current day highlighting for entire column and only
                    // apply the current-hour highlight to today's cell
                    const todayIndex = now.getDay() === 0 ? 6 : now.getDay() - 1;
                    if (day === todayIndex) {
                        cell.classList.add('current-day-cell');
                        if (isCurrentHour) {
                            cell.classList.add('current-hour-cell');
                        }
                    }

                    // Check for events at this local hour and day
                    const eventsAtThisTime = events.filter(e => {
                        if (!e.days.includes(day)) return false;
                        return e.times.some(t => {
                            const [serverHour, serverMinute] = t.split(':').map(Number);
                            const { hour: eventLocalHour } = convertServerTimeToLocal(serverHour, serverMinute);
                            return eventLocalHour === localHour;
                        });
                    });

                    if (eventsAtThisTime.length > 1) {
                        // Multiple events in same hour - position vertically by minute
                        const eventTimesData = eventsAtThisTime.map(event => {
                            const eventTime = event.times.find(t => {
                                const [serverHour, serverMinute] = t.split(':').map(Number);
                                const { hour: eventLocalHour } = convertServerTimeToLocal(serverHour, serverMinute);
                                return eventLocalHour === localHour;
                            });
                            const [serverHour, serverMinute] = eventTime.split(':').map(Number);
                            return { event, minute: serverMinute };
                        });
                        
                        // Sort by minute
                        eventTimesData.sort((a, b) => a.minute - b.minute);
                        
                        // Create events with vertical positioning
                        eventTimesData.forEach((data, index) => {
                            const eventDiv = document.createElement('div');
                                eventDiv.className = `scheduler-event event-${data.event.type}`;
                                // no per-event current-hour overlay; highlight applies to the cell only
                            
                            const topPercent = (data.minute / 60) * 100;
                            const nextMinute = index < eventTimesData.length - 1 ? eventTimesData[index + 1].minute : 60;
                            const heightPercent = ((nextMinute - data.minute) / 60) * 100;
                            
                            eventDiv.style.position = 'absolute';
                            eventDiv.style.top = `${topPercent}%`;
                            eventDiv.style.height = `${heightPercent}%`;
                            eventDiv.style.width = '100%';
                            
                            const isMobile = window.innerWidth <= 768;
                            const displayName = isMobile ? shortenEventName(data.event.name) : data.event.name;
                            eventDiv.innerHTML = `<span class="event-label">${displayName}</span>`;
                            eventDiv.title = data.event.name;
                            
                            cell.appendChild(eventDiv);
                        });
                    } else if (eventsAtThisTime.length === 1) {
                        // Single event - display normally
                        const eventDiv = document.createElement('div');
                        eventDiv.className = `scheduler-event event-${eventsAtThisTime[0].type}`;
                        // no per-event current-hour overlay; highlight applies to the cell only
                        
                        const isMobile = window.innerWidth <= 768;
                        const displayName = isMobile ? shortenEventName(eventsAtThisTime[0].name) : eventsAtThisTime[0].name;
                        eventDiv.innerHTML = `<span class="event-label">${displayName}</span>`;
                        eventDiv.title = eventsAtThisTime[0].name;
                        
                        cell.appendChild(eventDiv);
                    }

                    grid.appendChild(cell);
                }
            }

            // Auto-scroll to current hour after a brief delay to ensure DOM is ready
            setTimeout(() => scrollToCurrentHour(), 50);

            // Show or hide schedule notes depending on whether any events were rendered
            const scheduleNotes = document.getElementById('scheduleNotes');
            if (scheduleNotes) {
                const hasAnyEvent = grid.querySelector('.scheduler-event') !== null;
                scheduleNotes.style.display = hasAnyEvent ? 'none' : 'block';
            }
        }

        function setupLegendFilters() {
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const eventType = this.dataset.eventType;
                    
                    document.querySelectorAll(`.scheduler-event.event-${eventType}`).forEach(event => {
                        event.style.opacity = this.classList.contains('active') ? '1' : '0.3';
                    });
                });
            });
        }

        function updateNowHighlight() {
            const now = new Date();
            let currentDayOfWeek = now.getDay() === 0 ? 6 : now.getDay() - 1;
            const currentHour = now.getHours();
            
            // Remove previous day header highlights
            document.querySelectorAll('.day-header.today').forEach(header => {
                header.classList.remove('today');
            });
            
            // Highlight only the current day header
            const todayHeader = document.querySelector(`.day-header[data-day="${currentDayOfWeek}"]`);
            if (todayHeader) {
                todayHeader.classList.add('today');
                // Add position relative so ::after positioning works
                todayHeader.style.position = 'relative';
            }
            
            // Reassign current-hour classes so the highlight moves when the hour changes
            const todayIndex = currentDayOfWeek;
            // remove previous highlights
            document.querySelectorAll('.current-hour-cell').forEach(c => c.classList.remove('current-hour-cell'));

            // add highlight to the new current hour cell for today (if present)
            const newCell = document.querySelector(`.scheduler-cell[data-day="${todayIndex}"][data-hour="${currentHour}"]`);
            if (newCell) {
                newCell.classList.add('current-hour-cell');
            }

            // Update progressive fill for current hour cells
            updateCurrentHourFill();

            // Auto-scroll when the hour changes (so page scroll follows the clock)
            if (currentHour !== lastAutoScrollHour) {
                scrollToCurrentHour();
            }
        }

        function updateCurrentHourFill() {
            const now = new Date();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            // Calculate percentage through the hour (0-100%)
            const totalSeconds = minutes * 60 + seconds;
            const progressPercent = (totalSeconds / 3600) * 100;
            
            // No progressive fill: current hour highlighting uses border/background only
        }

        // Apply or remove hiding of empty hours rows
        function applyHideEmptyHours(shouldHide) {
            document.querySelectorAll('.hour-label-empty').forEach(el => {
                el.style.display = shouldHide ? 'none' : '';
            });
            document.querySelectorAll('.scheduler-cell-empty').forEach(el => {
                el.style.display = shouldHide ? 'none' : '';
            });

            const btn = document.getElementById('toggleEmptyHoursBtn');
            if (btn) {
                btn.textContent = shouldHide ? 'Show empty hours' : 'Hide empty hours';
                btn.setAttribute('aria-pressed', shouldHide ? 'true' : 'false');
            }
        }

        function toggleHideEmptyHours() {
            const key = 'schedulerHideEmptyHours';
            const current = localStorage.getItem(key) === 'true';
            const next = !current;
            localStorage.setItem(key, next ? 'true' : 'false');
            applyHideEmptyHours(next);
        }

        // Scroll scheduler wrapper to the current hour label and record that we scrolled
        function scrollToCurrentHour() {
            const now = new Date();
            const currentHour = now.getHours();
            const schedulerWrapper = document.querySelector('.scheduler-grid-wrapper');
            const currentHourLabel = document.querySelector(`[data-hour="${currentHour}"].hour-label`);
            if (schedulerWrapper && currentHourLabel) {
                const target = Math.max(0, currentHourLabel.offsetTop - 100);
                if ('scrollTo' in schedulerWrapper) {
                    try {
                        schedulerWrapper.scrollTo({ top: target, behavior: 'smooth' });
                    } catch (e) {
                        schedulerWrapper.scrollTop = target;
                    }
                } else {
                    schedulerWrapper.scrollTop = target;
                }
                lastAutoScrollHour = currentHour;
            }
        }

        function getAionGameTime(serverTime) {
            // The reference: RT 10:33:00 is GT 06:44:00.
            // This means GT 00:00:00 happened 33m 40s earlier RT (at 09:59:20).
            const reference = new Date(serverTime);
            reference.setHours(9, 59, 20, 0); 
            
            let diffMs = serverTime - reference;
            
            // Adjust for game time (12x speed)
            let totalGameSeconds = Math.floor((diffMs * 12) / 1000);
            
            // --- DATE CALCULATION START (Based on 18.05.296 anchor) ---
            // We calculate total days passed from Year 0 to 18.05.296
            // (296 years * 360 days) + (4 full months * 30 days) + 17 full days
            const baseDays = (296 * 360) + (4 * 30) + 17;
            const daysPassedSinceRef = Math.floor(totalGameSeconds / 86400);
            const totalDays = baseDays + daysPassedSinceRef;

            const gYear = Math.floor(totalDays / 360);
            const gMonth = Math.floor((totalDays % 360) / 30) + 1;
            const gDay = (totalDays % 30) + 1;
            // --- DATE CALCULATION END ---

            // Handle the 24-hour wrap around (KEEPING YOUR TIME LOGIC UNTOUCHED)
            const secondsInDay = 86400;
            let secondsToday = totalGameSeconds % secondsInDay;
            if (secondsToday < 0) secondsToday += secondsInDay;

            const h = Math.floor(secondsToday / 3600);
            const m = Math.floor((secondsToday % 3600) / 60);
            const s = secondsToday % 60;

            return {
                time: `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`,
                date: `${String(gDay).padStart(2, '0')}.${String(gMonth).padStart(2, '0')}.${gYear}`
            };
        }

        // Initialize
        window.addEventListener('load', () => {
            createSchedulerGrid();
            setupLegendFilters();
            updateTimeDisplays();
            updateNowHighlight();
            setInterval(() => {
                updateTimeDisplays();
                updateNowHighlight();
            }, 1000);
            // Initialize hide-empty-hours button from saved preference
            const key = 'schedulerHideEmptyHours';
            const saved = localStorage.getItem(key) === 'true';
            applyHideEmptyHours(saved);
            const toggleBtn = document.getElementById('toggleEmptyHoursBtn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleHideEmptyHours);
            }
            // No separate progressive fill interval; highlight updates on the 1s interval above
            document.getElementById('copyright-year').textContent = new Date().getFullYear();
        });
    </script>
</body>
</html>